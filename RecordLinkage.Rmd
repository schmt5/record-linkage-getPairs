---
title: "getPairs-Funktion im RecordLinkage-Package"
author: "Omar Besic, Thierry Schmidt, Chantal Zbinden"
date: "5/25/2019"
output:
  html_document:
    toc: true
---
<span style="color:blue">
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(RecordLinkage, quietly = TRUE)
```

## Das Paket: "RecordLinkage"
<p><span style="color:blue">"Provides functions for linking and de-duplicating data sets. Methods based on a stochastic approach are implemented as well as classification algorithms from the machine learning domain."</span></p>

### Vorgehen 1: Generating record pairs

#### 1. Data preprocessing
dataframe of 500 persons with firstname, second firstname, lastname, second lastname, birthyear, birthmonth and birthday

```{r dataframe}
data(RLdata500)
str(RLdata500)
head(RLdata500)
```

#### 2. Building comparison patterns 
--> "Bilder Paare"

<b>Auswahlm√∂glichkeiten:</b>

<li>compare: builds comparison of record pairs for deduplication or linkage</li>

<p><span style="color:blue">These functions build record pairs and finally comparison patterns by which these pairs are later classified as links or non-links. They make up the initial stage in a Record Linkage process after possibly normalizing data. Two general scenarios are reflected by the two functions: compare.dedup works on a single data set which is to be deduplicated, compare.linkage is intended for linking two data sets together.</span></p>
<p><span style="color:blue"><strong>blockfld</strong> = Blocking field definition. A list of integer or character vectors with column indices or FALSE to disable blocking. Each element of blockfld specifies a set of columns in which two records must agree to be included in the output. Each blocking definition in the list is applied individually, the sets obtained thereby are combined by a union operation. If blockfld is FALSE, no blocking will be performed, which leads to a large number of record pairs ((n(n-1))/2 where n is the number of records.</span></p>
<p><span style="color:blue">Phonetic codes and string similarity measures are supported for enhanced detection of misspellings.Applying a phonetic code leads to a binary value, where 1 denotes equality of the generated phonetic codes. A string comparator leads to a similarity value in the range [0,1] (0 lowest and 1 highest degree of similarity). String comparison is not allowed on a field for which a phonetic code is generated. For phonetic encoding functions included in the package.</span></p>
<p><span style="color:blue"><strong>strcmp</strong> = Determines usage of a string metric. Used in the same manner as phonetic.</span></p>
<p><span style="color:blue"><strong>strcmpfun</strong> = User-defined function for string metric.</span></p>

```{r compare}
#?compare.dedup()
rec.pairs <- compare.dedup(RLdata500,blockfld = list(1, 3, 5:7),strcmp = c(2,3,4),strcmpfun = levenshteinSim)
summary(rec.pairs)
```
Values: An object of class RecLinkPairs with the following components:
<li>data: copy of the records, converted to a data frame</li>
<li>pairs: generated comparison patterns</li>
<li>frequencies: for each column included in pairs, the average frequency of values (reciprocal of number of distinct values)</li>
<li>type</li>
```{r compare values}
str(rec.pairs)
```
<li>RLBigdataDedup </li>
```{r BigData compare}
#?RLBigDataDedup
data <- RLBigDataDedup(RLdata500, identity = identity.RLdata500, blockfld = list(1,3,5:7))
```
<li>RLBigdataLinkage </li>
</span
assign dataframe rec.paris$paris to matches and give me the matches of all rows on which the restriction had be defined in blockfld for 1 = same and 0 = not same

```{r matches}
matches <- rec.pairs$pairs
head(matches) #show first 6 record pairs
matches[2,] #show pair in row 2, (id1: 1, id2: 64)
RLdata500[1,] #show patient in row 1
RLdata500[64,] #show patient in row 64

matches[13,] #show pair in row 2, (id1: 2, id2: 43)
RLdata500[2,] #show patient in row 2
RLdata500[43,] #show patient in row 43
```

### Vorgehen 2: Add weight calculation
<p><span style="color:blue"><b>1. Variante mit epiWeight:</b>"Calculates weights for record paris based on the EpiLink approach"</span></p>
Werte von 0 bis 1

<p><span style="color:blue"><b>2. Variante mit emWeight:</b>"Calculates weights for Record Linkage based on an EM algorithm"</span></p>
Werte von -10 bis 35

#### epiWeigth in example
```{r weight}
rec.pairs <- epiWeights(rec.pairs)
length(rec.pairs$pairs$id1) #Anzahl Pairs
length(rec.pairs$Wdata) #Anzahl Weights
head(rec.pairs$Wdata) #Overview of data rparis - weights
```
For each pair a weight has been calculated

### Vorgehen 3: getPairs

<li>show paris with the weights of them</li>
<li>use filter on weights</li>

```{r getPairs}
head(getPairs(rec.pairs, min.weight=0.5, max.weight=0.6)) #show all record pairs with weights between 0.5 and 0.6
tail(getPairs(rec.pairs, min.weight=0.5, max.weight=0.6))
rpairs <- getPairs(rec.pairs, single.rows=FALSE) #generate pairs of data.frame rec.pairs
length(rpairs$id) #not number of pairs, if single.row = FALSE, because 1 pairs use 3 rows

```

### Vorgehen 4: Classification
"To select with "show" in getPairs() function, you need first to Classify your dataset with epiClassify() or emClassify() depending your approach (epiWeight or emWeight)"

<li><span style="color:blue"><strong>emClassify: </strong>Classifies data pairs to which weights were assigned by <b>emWeights</b>. Based on user-defined threholds or predefined error rates</span></li>
<p><span style="color:blue">Two general approaches are implemented. The classical procedure by Fellegi and Sunter minimizes the number of possible links with given error levels for false links (my) and false non-links (ny).</span></p>
<p><span style="color:blue">The second approach requires threholds for links and possible links to be set by the user. A pair with weight w is classified as a link if w >= threshold.upper, as a possible link if threhold.upper >= w >= threshold.lower and as a non-link if w < threshold.lower.</span></p>
<p><span style="color:blue">If threshold.upper or threshold.lower is given, the threshold-based approach is used, otherwise, if one of the error bounds is given, the Fellegi-Sunter model. If only my is supplied, links are chosen to meet the error bound and all other pairs are classified as non-links (the equivalent case holds if only ny is specified). If no further arguments than rpairs are given, a single threshold of 0 is used.</span></p>
<p><span style="color:blue">The quality of classification of the Fellegi-Sunter method relies strongly on resonable estimations of m- and u-probabilities. The results should be evaluated critically.</span></p>

<li><span style="color:blue"><strong>epClassify: </strong></span></li>

Neue Variablen: prediction und threshold

<li>Threshold.upper --> Schwellenwet ab wann Pairs zu links werden</li>
<li>Threshold.under --> Schwellenwert ab wann non-links zu possible links werden</li>

Possible prediction-levels: non-linked and linked (no possible's because only threshold.upper defined)

If no threshold.under is defined; treshold.under = treshold.upper 
</span>
```{r classify}
cldata <- epiClassify(rec.pairs, 0.5) #threshold.lower = threshold.upper if not defined
summary(cldata$prediction)
cldata <- epiClassify(rec.pairs, 0.6, 0.4)
summary(cldata$prediction)
head(getPairs(cldata, show="links", single.rows=FALSE)) #now we can filter, show="links", "nonlinks", "possible" or "all"
```

###False matches and false non-matches
Now we can check which of the pairs are false-negative and which are false-positive. 
In other words, which of these pairs form synonyms (false-negative) or homonyms (false-positive)?

<li><span style="color:blue"><strong>Synonym: </strong></span></li>
Example: Martin and M‰d‰: same person is meant, but the pair does not form a link
```{r Synonym, warning=FALSE, echo=FALSE}
data(RLdata500)
testdata <- RLdata500
data <- RLBigDataDedup(testdata, identity = identity.RLdata500,
                       blockfld=list(1,3,5:7),
                       strcmp = c(2,3,4),
                       strcmpfun = "levenshtein")
data <- epiWeights(data)
result <- epiClassify(data, 0.5)
```

Give me all synonyms based on my weight of 0.5

```{r getFalseNeg}
 getFalseNeg(result)
```

<li><span style="color:blue"><strong>Homonym: </strong></span></li>
Example: Jan and Jan: not the same person, but the pair forms a link because string is the same
```{r Homonym}
 getFalsePos(result)
```

### Fragestellung
<p><span style="color:red">"Dear Professor Sariyar: I am using your great tools to do matching. I got a quick question: In getPairs (matcher or links), we have filter.match = c("match", "unknown", "nonmatch"), filter.link = c("nonlink", "possible", "link"), do we have any ways to calculate theri confidence levels related? Thanks and best regards..."</span></p>

### Threshold determination

#### 1. Clerical Review

```{r threshold cl}

```
#### 2. getParetoThreshold
<p><span style="color:blue">Calculates a classification threshold based on a generalized Pareto distribution fitted to the weights distribution of the given data pairs</span></p>
```{r threshold parteo}

```
#### 3. optimalThreshold
<p><span style="color:blue">Calculates the optimal threshold for weight-based RecordLinkage</span></p> <ul><li><span style="color:blue">my = error bound for false positives</span></li><li><span style="color:blue">ny = error bound for false negatives</span></li>

```{r threshold optimal}

```

